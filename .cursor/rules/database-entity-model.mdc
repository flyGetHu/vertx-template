---
description:
globs:
alwaysApply: false
---
# 数据库实体模型规范

本规范定义了数据库实体类的标准结构、字段映射规则和维护要求，确保实体与数据库表结构保持同步。

## 实体类基本结构

### 1. 类注解和导入
```java
package com.vertx.template.model.entity;

import jakarta.validation.constraints.*;
import lombok.Data;
import java.time.LocalDateTime;
import java.time.LocalDate;
import java.time.LocalTime;
import java.time.Duration;
import java.math.BigDecimal;
import io.vertx.core.buffer.Buffer;
import io.vertx.core.json.JsonObject;
import io.vertx.core.json.JsonArray;

/**
 * [实体名称]实体类
 */
@Data
public class EntityName {
    // 实体字段定义
}
```

### 2. 必需组件
- **`@Data`** - 使用Lombok自动生成getter/setter
- **Jakarta Bean Validation** - 字段校验注解
- **JavaDoc注释** - 类和复杂字段的说明

## 字段定义规范

### MySQL 类型映射规范

根据 [Vert.x MySQL 客户端文档](mdc:https:/vertx.io/docs/vertx-mysql-client/java/#_mysql_type_mapping)，支持以下类型映射：

#### 数值类型

| MySQL类型 | Java类型 | 示例 | 说明 |
|-----------|----------|------|------|
| TINYINT | Byte | `private Byte status;` | 8位有符号整数 |
| SMALLINT | Short | `private Short count;` | 16位有符号整数 |
| MEDIUMINT | Integer | `private Integer mediumValue;` | 24位有符号整数 |
| INT/INTEGER | Integer | `private Integer count;` | 32位有符号整数 |
| BIGINT | Long | `private Long id;` | 64位有符号整数 |
| FLOAT | Float | `private Float rate;` | 单精度浮点数 |
| DOUBLE | Double | `private Double amount;` | 双精度浮点数 |
| DECIMAL/NUMERIC | BigDecimal | `private BigDecimal price;` | 精确数值，推荐用于金额 |
| BIT | Long | `private Long flags;` | 位字段，映射为Long |

#### 字符串类型

| MySQL类型 | Java类型 | 示例 | 说明 |
|-----------|----------|------|------|
| CHAR | String | `private String code;` | 固定长度字符串 |
| VARCHAR | String | `private String username;` | 可变长度字符串 |
| TINYTEXT | String | `private String shortDesc;` | 最大255字符 |
| TEXT | String | `private String content;` | 最大65535字符 |
| MEDIUMTEXT | String | `private String article;` | 最大16MB |
| LONGTEXT | String | `private String document;` | 最大4GB |
| ENUM | String | `private String status;` | 枚举值，作为字符串处理 |

#### 日期时间类型

| MySQL类型 | Java类型 | 示例 | 说明 |
|-----------|----------|------|------|
| DATE | LocalDate | `private LocalDate birthDate;` | 日期（年-月-日） |
| TIME | Duration | `private Duration workTime;` | 时间间隔 |
| TIME | LocalTime | `private LocalTime startTime;` | 一天中的时间点 |
| DATETIME | LocalDateTime | `private LocalDateTime createdAt;` | 日期时间（无时区） |
| TIMESTAMP | LocalDateTime | `private LocalDateTime updatedAt;` | 时间戳（含时区转换） |
| YEAR | Short | `private Short year;` | 年份 |

#### 二进制类型

| MySQL类型 | Java类型 | 示例 | 说明 |
|-----------|----------|------|------|
| BINARY | Buffer | `private Buffer data;` | 固定长度二进制 |
| VARBINARY | Buffer | `private Buffer content;` | 可变长度二进制 |
| TINYBLOB | Buffer | `private Buffer thumbnail;` | 最大255字节 |
| BLOB | Buffer | `private Buffer image;` | 最大65KB |
| MEDIUMBLOB | Buffer | `private Buffer video;` | 最大16MB |
| LONGBLOB | Buffer | `private Buffer file;` | 最大4GB |

#### 特殊类型

| MySQL类型 | Java类型 | 示例 | 说明 |
|-----------|----------|------|------|
| JSON | JsonObject/JsonArray | `private JsonObject metadata;` | JSON文档 |
| GEOMETRY | String | `private String location;` | 几何数据（WKT格式） |
| BOOLEAN | Boolean | `private Boolean active;` | 布尔值（TINYINT(1)） |

### 字段校验注解

根据业务需求添加适当的校验注解：

```java
// 必填字段
@NotBlank(message = "用户名不能为空")
@Size(min = 3, max = 50, message = "用户名长度必须在3-50之间")
private String username;

// 邮箱字段
@Email(message = "邮箱格式不正确")
private String email;

// 数值范围
@Min(value = 0, message = "价格必须大于等于0")
private BigDecimal price;

// 可选字段（无@NotBlank/@NotNull）
private String description;
```

## fromRow映射方法规范

### 标准实现模板

每个实体类**必须**包含 `fromRow` 静态工厂方法：

```java
/**
 * 从数据库Row对象创建实体实例
 * @param row 数据库查询结果行
 * @return 实体实例，如果row为null则返回null
 */
public static EntityName fromRow(io.vertx.sqlclient.Row row) {
    if (row == null) {
        return null;
    }

    final EntityName entity = new EntityName();
    entity.setId(row.getLong("id"));
    entity.setField1(row.getString("field1"));
    entity.setField2(row.getBoolean("field2"));
    entity.setCreatedAt(row.getLocalDateTime("created_at"));
    entity.setUpdatedAt(row.getLocalDateTime("updated_at"));
    return entity;
}
```

### 字段映射规则

1. **数据库字段命名**：使用下划线分隔（snake_case）
2. **Java字段命名**：使用驼峰命名（camelCase）
3. **映射对应关系**：
   ```java
   // 数据库字段: created_at -> Java字段: createdAt
   entity.setCreatedAt(row.getLocalDateTime("created_at"));

   // 数据库字段: user_name -> Java字段: userName
   entity.setUserName(row.getString("user_name"));
   ```

### Row对象类型转换方法

根据 MySQL 类型映射，使用对应的 Row 方法获取数据：

#### 数值类型转换

| Row方法 | 对应MySQL类型 | 示例 |
|---------|---------------|------|
| `getByte("field")` | TINYINT | `row.getByte("status")` |
| `getShort("field")` | SMALLINT, YEAR | `row.getShort("count")` |
| `getInteger("field")` | MEDIUMINT, INT | `row.getInteger("count")` |
| `getLong("field")` | BIGINT, BIT | `row.getLong("id")` |
| `getFloat("field")` | FLOAT | `row.getFloat("rate")` |
| `getDouble("field")` | DOUBLE | `row.getDouble("amount")` |
| `getBigDecimal("field")` | DECIMAL, NUMERIC | `row.getBigDecimal("price")` |

#### 字符串类型转换

| Row方法 | 对应MySQL类型 | 示例 |
|---------|---------------|------|
| `getString("field")` | CHAR, VARCHAR, TEXT系列, ENUM | `row.getString("username")` |

#### 日期时间类型转换

| Row方法 | 对应MySQL类型 | 示例 |
|---------|---------------|------|
| `getLocalDate("field")` | DATE | `row.getLocalDate("birth_date")` |
| `getLocalTime("field")` | TIME（作为时间点） | `row.getLocalTime("start_time")` |
| `getTemporal("field")` | TIME（作为时间间隔） | `row.getTemporal("work_time")` |
| `getLocalDateTime("field")` | DATETIME, TIMESTAMP | `row.getLocalDateTime("created_at")` |

#### 二进制和特殊类型转换

| Row方法 | 对应MySQL类型 | 示例 |
|---------|---------------|------|
| `getBuffer("field")` | BINARY, BLOB系列 | `row.getBuffer("image")` |
| `getJson("field")` | JSON | `row.getJson("metadata")` |
| `getBoolean("field")` | BOOLEAN(TINYINT(1)) | `row.getBoolean("active")` |

#### 通用获取方法

| Row方法 | 说明 | 示例 |
|---------|------|------|
| `getValue("field")` | 获取原始值 | `row.getValue("any_field")` |
| `get(Class<T>, "field")` | 按类型获取 | `row.get(String.class, "username")` |

## 数据库字段同步要求

### 强制同步规则

**当数据库表结构发生变化时，必须同步更新：**

1. **添加字段**：
   ```java
   // 1. 在实体类中添加对应属性
   private String newField;

   // 2. 在fromRow方法中添加映射
   entity.setNewField(row.getString("new_field"));
   ```

2. **删除字段**：
   ```java
   // 1. 从实体类中移除属性
   // 2. 从fromRow方法中移除对应映射
   ```

3. **修改字段类型**：
   ```java
   // 1. 更新实体类属性类型
   // 2. 更新fromRow方法中的类型转换方法
   // 3. 更新相关的校验注解
   ```

4. **重命名字段**：
   ```java
   // 1. 重命名实体类属性（保持驼峰命名）
   // 2. 更新fromRow方法中的数据库字段名
   ```

### 完整示例

参考 [User.java](mdc:src/main/java/com/vertx/template/model/entity/User.java) 的标准实现：

```java
package com.vertx.template.model.entity;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import lombok.Data;
import java.time.LocalDateTime;

/**
 * 用户实体类
 */
@Data
public class User {
    private Long id;

    @NotBlank(message = "用户名不能为空")
    @Size(min = 3, max = 50, message = "用户名长度必须在3-50之间")
    private String username;

    @NotBlank(message = "密码不能为空")
    @Size(min = 6, max = 100, message = "密码长度必须在6-100之间")
    private String password;

    @Email(message = "邮箱格式不正确")
    private String email;

    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
    private boolean active;

    /**
     * 从数据库Row对象创建用户实例
     * @param row 数据库查询结果行
     * @return 用户实例，如果row为null则返回null
     */
    public static User fromRow(io.vertx.sqlclient.Row row) {
        if (row == null) {
            return null;
        }

        final User user = new User();
        user.setId(row.getLong("id"));
        user.setUsername(row.getString("username"));
        user.setPassword(row.getString("password"));
        user.setEmail(row.getString("email"));
        user.setCreatedAt(row.getLocalDateTime("created_at"));
        user.setUpdatedAt(row.getLocalDateTime("updated_at"));
        user.setActive(row.getBoolean("active"));
        return user;
    }
}
```

## 特殊类型处理规范

### JSON 类型处理

```java
// 实体类中定义JSON字段
private JsonObject metadata;
private JsonArray tags;

// fromRow方法中的JSON处理
public static Product fromRow(io.vertx.sqlclient.Row row) {
    // ...
    product.setMetadata(row.getJson("metadata").asJsonObject());
    product.setTags(row.getJson("tags").asJsonArray());
    return product;
}
```

### ENUM 类型处理

```java
// Java枚举定义
public enum UserStatus {
    ACTIVE, INACTIVE, SUSPENDED
}

// 实体类中使用
private UserStatus status;

// fromRow方法中的枚举处理
user.setStatus(UserStatus.valueOf(row.getString("status")));
```

### TIME 类型的双重处理

```java
// 作为时间间隔使用
private Duration workDuration;
entity.setWorkDuration((Duration) row.getTemporal("work_duration"));

// 作为一天中的时间点使用
private LocalTime startTime;
entity.setStartTime(row.getLocalTime("start_time"));
```

### BIT 类型处理

```java
// BIT字段映射为Long
private Long permissions;

// 处理BIT(64)最大值的特殊情况
entity.setPermissions(row.getLong("permissions")); // 可能返回-1L表示最大值
```

### GEOMETRY 类型处理

```java
// GEOMETRY数据作为WKT字符串处理
private String location;
entity.setLocation(row.getString("location")); // 例如: "POINT(1 1)"
```

## 最佳实践

### 1. 字段顺序
- ID字段放在最前面
- 业务字段按逻辑分组
- JSON/BLOB等大字段放在中间
- 时间戳字段（createdAt, updatedAt）放在最后
- 状态字段（active, deleted等）放在时间戳字段前

### 2. 校验注解使用
- 所有必填字段添加 `@NotBlank` 或 `@NotNull`
- 字符串字段添加 `@Size` 限制长度
- 邮箱字段使用 `@Email`
- 数值字段使用 `@Min`, `@Max` 限制范围
- JSON字段可以添加自定义校验器

### 3. 命名约定
- 实体类名使用单数形式（User, Product, Order）
- 字段名使用驼峰命名法
- 布尔字段使用 is/has 前缀（isActive, hasPermission）
- JSON字段使用描述性名称（metadata, settings, config）

### 4. 类型选择建议
- **金额字段**：使用 `BigDecimal` 而非 `Double`
- **时间戳**：优先使用 `LocalDateTime`，避免时区问题
- **状态字段**：使用 `ENUM` + Java枚举，提高类型安全
- **大文本**：根据长度选择 TEXT/MEDIUMTEXT/LONGTEXT
- **二进制数据**：小文件用 BLOB，大文件存储路径用 VARCHAR

### 5. 重要注意事项

#### 时区处理
根据 [Vert.x MySQL 文档](mdc:https:/vertx.io/docs/vertx-mysql-client/java/#_mysql_type_mapping)：
- **DATETIME**：不包含时区信息，存储和读取的值完全一致
- **TIMESTAMP**：包含时区信息，会根据当前会话时区进行转换
- 建议：统一使用 UTC 时区存储，应用层处理时区转换

#### 数值精度
- **金额计算**：必须使用 `BigDecimal`，避免浮点数精度问题
- **BIT类型**：Java 无无符号数概念，BIT(64) 最大值会显示为 `-1L`

#### 性能考虑
- **大字段**：BLOB/TEXT 字段按需加载，避免影响查询性能
- **JSON字段**：合理设计JSON结构，避免过深嵌套

### 6. 维护检查清单

每次数据库表结构变更后，检查：
- [ ] 实体类字段是否与数据库表字段一一对应
- [ ] fromRow方法是否包含所有字段的映射
- [ ] 字段类型是否正确匹配（参考MySQL类型映射表）
- [ ] 校验注解是否符合业务规则
- [ ] 特殊类型（JSON、ENUM、TIME）是否正确处理
- [ ] 相关的Repository和Service是否需要更新
- [ ] 时区敏感字段是否正确处理

## 相关规范

- [编码规范](mdc:coding-standards.mdc) - 变量命名和方法设计
- [MVC架构](mdc:mvc-architecture.mdc) - 实体在架构中的位置
- [API响应处理](mdc:api-response-handler.mdc) - 实体数据的响应格式化
